<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <title>装饰者(decorator)的结构</title>

    <script type="text/javascript" src="Interface.js"></script>
</head>
    <body>
        <ul>
            <li id='example'>
                装饰者模式是一种为对象添加特性的技术，它并不使用创建新子类这种手段。
                可以用来透明地把对象包装在具有同样接口的另一对象之中。
            </li>
        </ul>
        <h4>装饰者模式与组合模式的比较：</h4>
        <ul>
            <li>
                装饰者对象和组合对象都是用来包装别的对象（那些对象在组合模式中称为子对象，而在装饰者模式中称为组件），
                他们都与所包装的对象实现同样的接口并且会把任何方法调用传递给这些对象。
            </li>
            <li>
                组合模式是一种结构型模式，用于把众多子对象组织为一个整体。籍此程序员与大批对象打交道时可以将它们当做一个对象来对待，并将它们组织为<font color='red'>层次性的树</font>。
                通常它并不修改方法调用，而只是将其沿着组合对象和子对象的链向下传递，直到到达并落实在叶对象上。
            </li>
            <li>
                装饰者模式也是一种结构型模式，但它并非用于组织对象，而是用于在不修改现有对象或从其派生子类的前提下为其增添职责。
                在一些较简单的例子中，装饰者会透明而不加修改地传递所有方法调用，不过，创建装饰者的目的就在于对方法进行修改。
            </li>
            <li>
                尽管简单的组合对象可等同于简单的装饰者，这二者却有着不同的焦点。组合对象并不修改方法调用，其着眼点在于组织子对象。而
                装饰者存在的唯一目的就是修改方法调用而不是组织子对象，因为子对象只有一个。
            </li>
        </ul>
    </body>
    <script type="text/javascript">
        var Bicycle = new Interface('Bicycle', ['assemble', 'wash', 'ride', 'repair', 'getPrice']);

        var AcmeComfortCruiser = function(){// implements Bicyle

        };

        AcmeComfortCruiser.prototype = {
            assemble: function(){},
            wash: function(){},
            ride: function(){},
            repair: function(){},
            getPrice: function(){
                return 399.00;
            }
        };

        /* BicycleDecorator abstract decorator class */
        var BicycleDecorator = function(bicycle){
            Interface.ensureImplements(bicycle, Bicycle);
            this.bicycle = bicycle;
        };

        BicycleDecorator.prototype = {
            assemble: function(){
                return this.bicycle.assemble();
            },
            wash: function(){
                return this.bicycle.wash();
            },
            ride: function(){
                return this.bicycle.ride();
            },
            repair: function(){
                return this.bicycle.repair();
            },
            getPrice: function(){
                return this.bicycle.getPrice();
            }
        };


        /* HeadlightDecorator class */
        var HeadlightDecorator = function(bicycle){//implements Bicycle
                HeadlightDecorator.superclass.constructor.call(this, bicycle);
        };
        extend(HeadlightDecorator, BicycleDecorator);
        HeadlightDecorator.prototype.assemble = function(){
            return this.bicycle.assemble() + ' Attach headlight to handlebars';
        };
        HeadlightDecorator.prototype.getPrice = function(){
            return this.bicycle.getPrice() + 15.00;
        };

        /* TaillightDecorator class */
        var TaillightDecorator = function(bicycle){
            TaillightDecorator.superclass.constructor.call(this, bicycle);
        };
        extend(TaillightDecorator, BicycleDecorator);
        TaillightDecorator.prototype.assemble = function(){
            return this.bicycle.assemble() + ' Attach taillight to handlebars';
        };
        TaillightDecorator.prototype.getPrice = function(){
            return this.bicycle.getPrice() + 9.00;
        };


        /*
        var myBicycle = new AcmeComfortCruiser();
        alert(myBicycle.getPrice());

        var headlightBciycle = new HeadlightDecorator(myBicycle);
        alert(headlightBciycle.getPrice());


        var taillightBicycle = new TaillightDecorator(headlightBciycle);
        alert(taillightBicycle.getPrice());
        */

        /*FrameColorDecorator class*/
        var FrameColorDecorator  = function(bicycle, frameColor){
            FrameColorDecorator.superclass.constructor.call(this, bicycle);
            this.frameColor = frameColor;
        };
        extend(FrameColorDecorator, BicycleDecorator);
        FrameColorDecorator.prototype.assemble = function(){
            //在方法之前添加行为
            return "Paint the frame " + this.frameColor + ' and allow it to dry.' + this.bicycle.assemble();
        };
        FrameColorDecorator.prototype.getPrice = function(){
            //在方法之后添加行为
            return this.bicycle.getPrice() + 30.00;
        };

        var myBicycle = new AcmeComfortCruiser();
        myBicycle = new FrameColorDecorator(myBicycle, 'red');

        myBicycle = new HeadlightDecorator(myBicycle);
        myBicycle = new HeadlightDecorator(myBicycle);

        myBicycle = new TaillightDecorator(myBicycle);

        alert(myBicycle.assemble());




        
    </script>
</html>
